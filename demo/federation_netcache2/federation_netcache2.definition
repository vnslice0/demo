{"sliverTotalCnt":6,"vvLinkTotalCnt":7,"vportTotalCnt":0,"sliceName":"","nsList":[{"id":"ns0","name":"VN1:SP","blkList":[{"id":"ns0_bk0","name":"FromDevice","instanceName":"FromDevice0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","clickInfo":"FromDevice(eth2, PROMISC true)","blockDefId":"FromDevice-1.0","orientation":0,"definition":{"name":"FromDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"FromDevice(DEVNAME [, keywords PROMISC, BURST, TIMESTAMP...])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/FromDevice/undefined","blockDefId":"FromDevice-1.0","ports":[{"name":"out0","portIndex":0,"role":"output","processing":"push","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":10,"cy":16,"id":"ns0_bk0_po0","multiplicity":"*","name":"out0","path":"M 8 14 L 12 14 L 12 18 L 8 18 z","portIndex":0,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":30,"cy":16,"id":"ns0_bk0_po1","multiplicity":"*","name":"vport0","path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk0_po0","name":"out0","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk0_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk1","name":"FromDevice","instanceName":"FromDevice1","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","clickInfo":"FromDevice(eth1, PROMISC true)","blockDefId":"FromDevice-1.0","orientation":0,"definition":{"name":"FromDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"FromDevice(DEVNAME [, keywords PROMISC, BURST, TIMESTAMP...])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/FromDevice/undefined","blockDefId":"FromDevice-1.0","ports":[{"name":"out0","portIndex":0,"role":"output","processing":"push","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":10,"cy":16,"id":"ns0_bk1_po0","multiplicity":"*","name":"out0","path":"M 8 14 L 12 14 L 12 18 L 8 18 z","portIndex":0,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":30,"cy":16,"id":"ns0_bk1_po1","multiplicity":"*","name":"vport0","path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk1_po0","name":"out0","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk1_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk2","name":"ToDevice","instanceName":"ToDevice0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","clickInfo":"ToDevice(eth2)","blockDefId":"ToDevice-1.0","orientation":0,"definition":{"name":"ToDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"ToDevice(DEVNAME [, BURST, KEYWORDS])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/ToDevice/undefined","blockDefId":"ToDevice-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"pull","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk2_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"pull","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk2_po1","multiplicity":"*","name":"vport0","path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk2_po0","name":"in0","role":"input","processing":"pull","multiplicity":"*"},{"enable":true,"id":"ns0_bk2_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk4","name":"Queue","instanceName":"Queue0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","clickInfo":"Queue()","blockDefId":"Queue-1.0","orientation":0,"definition":{"name":"Queue","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","bgColor":"undefined","clickInfo":"QueueQueue(CAPACITY)","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Packet_Storage/Queue/undefined","blockDefId":"Queue-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk4_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk4_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk4_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns0_bk4_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns0_bk4_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk5","name":"Queue","instanceName":"Queue1","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","clickInfo":"Queue()","blockDefId":"Queue-1.0","orientation":0,"definition":{"name":"Queue","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","bgColor":"undefined","clickInfo":"QueueQueue(CAPACITY)","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Packet_Storage/Queue/undefined","blockDefId":"Queue-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk5_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk5_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk5_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns0_bk5_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns0_bk5_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk12","name":"EtherSwitch","instanceName":"EtherSwitch0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Ethernet","description":"Expects and produces Ethernet packets.  Each pair of corresponding ports\r\n(e.g., input 0 and output 0, and input 1 and output 1, and so forth)\r\ncorresponds to a LAN.  Acts as a learning, forwarding Ethernet switch among\r\nthose LANs.\r\nOn receiving a packet on input port I with source address A, EtherSwitch\r\nassociates A with I.  Future packets destined for A are sent to output I\r\n(unless they came from input I, in which case they are dropped).  Packets sent\r\nto an unknown destination address are forwarded to every output port, except\r\nthe one corresponding to the packet's input port.  The TIMEOUT parameter\r\naffects how long port associations last.  If it is 0, then the element does\r\nnot learn addresses, and acts like a dumb hub.\r\nKeyword arguments are:\r\n\r\n\r\n TIMEOUT\r\n The timeout for port associations, in seconds.  Any port mapping (i.e.,\r\nbinding between an address and a port number) is dropped after TIMEOUT seconds\r\nof inactivity.  If 0, the element acts like a dumb hub.  Default is 300.\r\n\r\n\r\n","clickInfo":"EtherSwitch()","blockDefId":"EtherSwitch-1.0","orientation":0,"definition":{"name":"EtherSwitch","type":"click-user","ver":"1.0","maxInstance":"*","category":"Ethernet","description":"Expects and produces Ethernet packets.  Each pair of corresponding ports\r\n(e.g., input 0 and output 0, and input 1 and output 1, and so forth)\r\ncorresponds to a LAN.  Acts as a learning, forwarding Ethernet switch among\r\nthose LANs.\r\nOn receiving a packet on input port I with source address A, EtherSwitch\r\nassociates A with I.  Future packets destined for A are sent to output I\r\n(unless they came from input I, in which case they are dropped).  Packets sent\r\nto an unknown destination address are forwarded to every output port, except\r\nthe one corresponding to the packet's input port.  The TIMEOUT parameter\r\naffects how long port associations last.  If it is 0, then the element does\r\nnot learn addresses, and acts like a dumb hub.\r\nKeyword arguments are:\r\n\r\n\r\n TIMEOUT\r\n The timeout for port associations, in seconds.  Any port mapping (i.e.,\r\nbinding between an address and a port number) is dropped after TIMEOUT seconds\r\nof inactivity.  If 0, the element acts like a dumb hub.  Default is 300.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"EtherSwitch([keywords TIMEOUT])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Ethernet/EtherSwitch/undefined","blockDefId":"EtherSwitch-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"push","val":null,"path":"M 4.666666666666667 0 L 8.666666666666668 0 L 6.666666666666667 4 z","cx":6.666666666666667,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"in1","portIndex":1,"role":"input","processing":"push","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"in2","portIndex":2,"role":"input","processing":"push","val":null,"path":"M 31.333333333333336 0 L 35.333333333333336 0 L 33.333333333333336 4 z","cx":33.333333333333336,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":3,"role":"output","processing":"push","val":null,"path":"M 4.666666666666667 14 L 8.666666666666668 14 L 8.666666666666668 18 L 4.666666666666667 18 z","cx":6.666666666666667,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":4,"role":"output","processing":"push","val":null,"path":"M 18 14 L 22 14 L 22 18 L 18 18 z","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out2","portIndex":5,"role":"output","processing":"push","val":null,"path":"M 31.333333333333336 14 L 35.333333333333336 14 L 35.333333333333336 18 L 31.333333333333336 18 z","cx":33.333333333333336,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":6.666666666666667,"cy":2,"id":"ns0_bk12_po0","multiplicity":"*","name":"in0","path":"M 4.666666666666667 0 L 8.666666666666668 0 L 6.666666666666667 4 z","portIndex":0,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk12_po1","multiplicity":"*","name":"in1","path":"M 18 0 L 22 0 L 20 4 z","portIndex":1,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":33.333333333333336,"cy":2,"id":"ns0_bk12_po2","multiplicity":"*","name":"in2","path":"M 31.333333333333336 0 L 35.333333333333336 0 L 33.333333333333336 4 z","portIndex":2,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":6.666666666666667,"cy":16,"id":"ns0_bk12_po3","multiplicity":"*","name":"out0","path":"M 4.666666666666667 14 L 8.666666666666668 14 L 8.666666666666668 18 L 4.666666666666667 18 z","portIndex":3,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk12_po4","multiplicity":"*","name":"out1","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":4,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":33.333333333333336,"cy":16,"id":"ns0_bk12_po5","multiplicity":"*","name":"out2","path":"M 31.333333333333336 14 L 35.333333333333336 14 L 35.333333333333336 18 L 31.333333333333336 18 z","portIndex":5,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk12_po0","name":"in0","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po1","name":"in1","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po2","name":"in2","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po3","name":"out0","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po4","name":"out1","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po5","name":"out2","role":"output","processing":"push","multiplicity":"*"}]},{"id":"ns0_bk15","name":"KernelTap","instanceName":"KernelTap0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Host_and_Socket_Communication","description":"Reads Ethernet packets from and writes Ethernet packets to a /dev/tun* or\r\n/dev/tap* device.  This allows a user-level Click to hand packets to the\r\nvirtual Ethernet device.  KernelTap will also transfer packets from the\r\nvirtual Ethernet device.\r\nKernelTap allocates a /dev/tun* or tap* device (this might fail) and runs\r\nifconfig to set the interface's local (i.e., kernel) address to ADDR and\r\nthe netmask to MASK.  If a nonzero GATEWAY IP address (which must be on the\r\nsame network as the tun) is specified, then KernelTap tries to set up a\r\ndefault route through that host.\r\nKeyword arguments are:\r\n\r\n\r\n ETHER\r\n Ethernet address. Specifies the fake device's Ethernet address. Default is\r\n00:01:02:03:04:05. On Linux, you must supply an ETHER argument, and use that\r\naddress as the destination Ethernet address for all packets sent to the tap\r\nelement; otherwise, Linux will ignore your packets. On FreeBSD, there is no\r\nway to set the Ethernet address, and any ETHER argument is silently ignored,\r\nbut it is safe to use any destination Ethernet address for packets sent to the\r\ntap.\r\n\r\n\r\n\r\n\r\n MTU\r\n Integer.  The interface's maximum transmission unit, not including the\r\nEthernet header.  Default is 1500; some operating systems do not allow it to\r\nbe set.\r\n\r\n\r\n\r\n\r\n HEADROOM\r\n Integer.  The number of bytes left empty before the packet data (to leave room\r\nfor additional encapsulation headers).  Default is 0.\r\n\r\n\r\n\r\n\r\n IGNORE_QUEUE_OVERFLOWS\r\n Boolean.  If true, don't print more than one error message when there are\r\nqueue overflow errors (ENOBUFS) when sending or receiving packets via the tun\r\ndevice.  Default is false.\r\nKernelTap accepts the same arguments as KernelTun.\r\n\r\n\r\n","clickInfo":"KernelTap(10.1.1.1/24, ETHER 12:0d:4e:d0:77:85)","blockDefId":"KernelTap-1.0","orientation":0,"definition":{"name":"KernelTap","type":"click-user","ver":"1.0","maxInstance":"*","category":"Host_and_Socket_Communication","description":"Reads Ethernet packets from and writes Ethernet packets to a /dev/tun* or\r\n/dev/tap* device.  This allows a user-level Click to hand packets to the\r\nvirtual Ethernet device.  KernelTap will also transfer packets from the\r\nvirtual Ethernet device.\r\nKernelTap allocates a /dev/tun* or tap* device (this might fail) and runs\r\nifconfig to set the interface's local (i.e., kernel) address to ADDR and\r\nthe netmask to MASK.  If a nonzero GATEWAY IP address (which must be on the\r\nsame network as the tun) is specified, then KernelTap tries to set up a\r\ndefault route through that host.\r\nKeyword arguments are:\r\n\r\n\r\n ETHER\r\n Ethernet address. Specifies the fake device's Ethernet address. Default is\r\n00:01:02:03:04:05. On Linux, you must supply an ETHER argument, and use that\r\naddress as the destination Ethernet address for all packets sent to the tap\r\nelement; otherwise, Linux will ignore your packets. On FreeBSD, there is no\r\nway to set the Ethernet address, and any ETHER argument is silently ignored,\r\nbut it is safe to use any destination Ethernet address for packets sent to the\r\ntap.\r\n\r\n\r\n\r\n\r\n MTU\r\n Integer.  The interface's maximum transmission unit, not including the\r\nEthernet header.  Default is 1500; some operating systems do not allow it to\r\nbe set.\r\n\r\n\r\n\r\n\r\n HEADROOM\r\n Integer.  The number of bytes left empty before the packet data (to leave room\r\nfor additional encapsulation headers).  Default is 0.\r\n\r\n\r\n\r\n\r\n IGNORE_QUEUE_OVERFLOWS\r\n Boolean.  If true, don't print more than one error message when there are\r\nqueue overflow errors (ENOBUFS) when sending or receiving packets via the tun\r\ndevice.  Default is false.\r\nKernelTap accepts the same arguments as KernelTun.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"KernelTap(ADDR/MASK [, GATEWAY, keywords ETHER, MTU, HEADROOM, IGNORE_QUEUE_OVERFLOWS])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Host_and_Socket_Communication/KernelTap/undefined","blockDefId":"KernelTap-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk15_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk15_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk15_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns0_bk15_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns0_bk15_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk19","name":"Queue","instanceName":"Queue2","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","clickInfo":"Queue()","blockDefId":"Queue-1.0","orientation":0,"definition":{"name":"Queue","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","bgColor":"undefined","clickInfo":"QueueQueue(CAPACITY)","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Packet_Storage/Queue/undefined","blockDefId":"Queue-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk19_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk19_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk19_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns0_bk19_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns0_bk19_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk22","name":"ToDevice","instanceName":"ToDevice1","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","clickInfo":"ToDevice(eth1)","blockDefId":"ToDevice-1.0","orientation":0,"definition":{"name":"ToDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"ToDevice(DEVNAME [, BURST, KEYWORDS])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/ToDevice/undefined","blockDefId":"ToDevice-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"pull","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk22_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"pull","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk22_po1","multiplicity":"*","name":"vport0","path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk22_po0","name":"in0","role":"input","processing":"pull","multiplicity":"*"},{"enable":true,"id":"ns0_bk22_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns0_bk23","name":"NetCacheIngress","instanceName":"NetCacheIngress0","type":"click-user","ver":"1.0","maxInstance":"*","category":"COMPOUND_ELEMENTS","description":"","clickInfo":"NetCacheIngress_1_0(50000, 50001)","blockDefId":"NetCacheIngress-1.0","orientation":0,"definition":{"name":"NetCacheIngress","type":"click-user","ver":"1.0","maxInstance":"*","category":"COMPOUND_ELEMENTS","description":"","bgColor":"rgb(255, 255, 255)","clickInfo":"NetCacheIngress_1_0($PORT1, $PORT2)","isCompound":true,"elementclassText":"elementclass NetCacheIngress_1_0 {\r\n    $PORT1, $PORT2 |\r\n    Classifier0 :: Classifier(12/0800, -);\r\n    Strip0 :: Strip(14);\r\n    Align0 :: Align(4, 0);\r\n    CheckIPHeader0 :: CheckIPHeader();\r\n    IPClassifier0 :: IPClassifier(tcp, -);\r\n    NetCacheElement0 :: NetCacheElement(INGRESS);\r\n    IPClassifier1 :: IPClassifier(dst port $PORT1 or $PORT2, -);\r\n    Unstrip0 :: Unstrip(14);\r\n    SetIPChecksum0 :: SetIPChecksum();\r\n    Unstrip1 :: Unstrip(14);\r\n    Null0 :: Null;\r\n    Discard0 :: Discard();\r\n    FromSocket0 :: FromSocket(Udp, 0.0.0.0, $PORT1);\r\n    FromSocket1 :: FromSocket(Udp, 0.0.0.0, $PORT2);\r\n\r\n    input -> Classifier0;\r\n    Classifier0[1] -> Null0;\r\n    Classifier0 -> Strip0;\r\n    Strip0 -> Align0;\r\n    Align0 -> CheckIPHeader0;\r\n    CheckIPHeader0 -> IPClassifier0;\r\n    IPClassifier0 -> NetCacheElement0;\r\n    NetCacheElement0 -> IPClassifier1;\r\n    IPClassifier1 -> Discard0;\r\n    IPClassifier0[1] -> Unstrip0;\r\n    Unstrip0 -> Null0;\r\n    IPClassifier1[1] -> SetIPChecksum0;\r\n    SetIPChecksum0 -> Unstrip1;\r\n    Unstrip1 -> Null0;\r\n    FromSocket0 -> [1]NetCacheElement0;\r\n    FromSocket1 -> [2]NetCacheElement0;\r\n    Null0 -> output;\r\n } ","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/COMPOUND_ELEMENTS/NetCacheIngress/undefined","blockDefId":"NetCacheIngress-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"push","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 18 14 L 22 14 L 22 18 L 18 18 z","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns0_bk23_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns0_bk23_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"isCompound":true,"elementclassText":"elementclass NetCacheIngress_1_0 {\r\n    $PORT1, $PORT2 |\r\n    Classifier0 :: Classifier(12/0800, -);\r\n    Strip0 :: Strip(14);\r\n    Align0 :: Align(4, 0);\r\n    CheckIPHeader0 :: CheckIPHeader();\r\n    IPClassifier0 :: IPClassifier(tcp, -);\r\n    NetCacheElement0 :: NetCacheElement(INGRESS);\r\n    IPClassifier1 :: IPClassifier(dst port $PORT1 or $PORT2, -);\r\n    Unstrip0 :: Unstrip(14);\r\n    SetIPChecksum0 :: SetIPChecksum();\r\n    Unstrip1 :: Unstrip(14);\r\n    Null0 :: Null;\r\n    Discard0 :: Discard();\r\n    FromSocket0 :: FromSocket(Udp, 0.0.0.0, $PORT1);\r\n    FromSocket1 :: FromSocket(Udp, 0.0.0.0, $PORT2);\r\n\r\n    input -> Classifier0;\r\n    Classifier0[1] -> Null0;\r\n    Classifier0 -> Strip0;\r\n    Strip0 -> Align0;\r\n    Align0 -> CheckIPHeader0;\r\n    CheckIPHeader0 -> IPClassifier0;\r\n    IPClassifier0 -> NetCacheElement0;\r\n    NetCacheElement0 -> IPClassifier1;\r\n    IPClassifier1 -> Discard0;\r\n    IPClassifier0[1] -> Unstrip0;\r\n    Unstrip0 -> Null0;\r\n    IPClassifier1[1] -> SetIPChecksum0;\r\n    SetIPChecksum0 -> Unstrip1;\r\n    Unstrip1 -> Null0;\r\n    FromSocket0 -> [1]NetCacheElement0;\r\n    FromSocket1 -> [2]NetCacheElement0;\r\n    Null0 -> output;\r\n } ","portsTemplate":[{"enable":true,"id":"ns0_bk23_po0","name":"in0","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk23_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"}]}],"blkTotalCnt":24,"vpoList":[{"id":"ns0_vp0","name":"eth1","ports":[{"connCount":2,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"left","role":"nsvport"}],"mac":"12:0d:4e:d0:77:85"},{"id":"ns0_vp1","name":"eth2","ports":[{"connCount":2,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"right","role":"nsvport"}],"mac":"12:31:36:bf:5c:9c"},{"id":"ns0_vp2","name":"eth3","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"right","role":"nsvport"}],"mac":"12:24:88:ca:77:07"}],"vpoTotalCnt":4,"lnkList":[{"id":"ns0_link11","sourceId":"ns0_bk1","targetId":"ns0_bk12","left":false,"right":true,"srcPortIdx":0,"dstPortIdx":1,"className":"link bblink"},{"id":"ns0_link15","sourceId":"ns0_bk15","targetId":"ns0_bk12","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":2,"className":"link bblink"},{"id":"ns0_link16","sourceId":"ns0_bk12","targetId":"ns0_bk4","left":false,"right":true,"srcPortIdx":3,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link17","sourceId":"ns0_bk4","targetId":"ns0_bk2","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link18","sourceId":"ns0_bk12","targetId":"ns0_bk5","left":false,"right":true,"srcPortIdx":4,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link20","sourceId":"ns0_bk12","targetId":"ns0_bk19","left":false,"right":true,"srcPortIdx":5,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link21","sourceId":"ns0_bk19","targetId":"ns0_bk15","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link26","sourceId":"ns0_bk5","targetId":"ns0_bk22","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link29","sourceId":"ns0_bk0","targetId":"ns0_vp1","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns0_link30","sourceId":"ns0_bk1","targetId":"ns0_vp0","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns0_link31","sourceId":"ns0_bk2","targetId":"ns0_vp1","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns0_link32","sourceId":"ns0_bk22","targetId":"ns0_vp0","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns0_link33","sourceId":"ns0_bk0","targetId":"ns0_bk23","left":false,"right":true,"srcPortIdx":0,"dstPortIdx":0,"className":"link bblink"},{"id":"ns0_link34","sourceId":"ns0_bk23","targetId":"ns0_bk12","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"}],"lnkTotalCnt":35,"sliceName":"","hostname":""},{"id":"ns1","name":"VN2:SP","blkList":[],"blkTotalCnt":0,"vpoList":[{"id":"ns1_vp0","name":"eth1","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"left","role":"nsvport"}],"mac":"12:25:22:d0:77:85"},{"id":"ns1_vp1","name":"eth2","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"top","role":"nsvport"}],"mac":"12:bb:33:bf:5c:9c"}],"vpoTotalCnt":2,"lnkList":[],"lnkTotalCnt":0,"sliceName":"","hostname":""},{"id":"ns2","name":"VN3:SP","blkList":[],"blkTotalCnt":22,"vpoList":[{"id":"ns2_vp0","name":"eth1","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"bottom","role":"nsvport"}],"mac":"12:3b:ab:d0:77:85"},{"id":"ns2_vp1","name":"eth2","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"left","role":"nsvport"}],"mac":"12:dc:13:bf:5c:9c"}],"vpoTotalCnt":2,"lnkList":[],"lnkTotalCnt":24,"sliceName":"","hostname":""},{"id":"ns3","name":"PG:NS:PN1","blkList":[{"id":"ns3_bk0","name":"FromDevice","instanceName":"FromDevice0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","clickInfo":"FromDevice(vlan327, PROMISC true)","blockDefId":"FromDevice-1.0","orientation":0,"definition":{"name":"FromDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"FromDevice(DEVNAME [, keywords PROMISC, BURST, TIMESTAMP...])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/FromDevice/undefined","blockDefId":"FromDevice-1.0","ports":[{"name":"out0","portIndex":0,"role":"output","processing":"push","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":10,"cy":16,"id":"ns3_bk0_po0","multiplicity":"*","name":"out0","path":"M 8 14 L 12 14 L 12 18 L 8 18 z","portIndex":0,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":30,"cy":16,"id":"ns3_bk0_po1","multiplicity":"*","name":"vport0","path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk0_po0","name":"out0","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns3_bk0_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk1","name":"FromDevice","instanceName":"FromDevice1","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","clickInfo":"FromDevice(vlan309, PROMISC true)","blockDefId":"FromDevice-1.0","orientation":0,"definition":{"name":"FromDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the FromDevice\r\nelement. For the user-level element, read the FromDevice.u manual page.\r\nIntercepts all packets received by the Linux network interface named DEVNAME\r\nand pushes them out output 0.  The packets include the link-level header.\r\nDEVNAME may also be an Ethernet address, in which case FromDevice searches for\r\na device with that address.\r\nFromDevice receives packets at interrupt time and stores them in an internal\r\nqueue.  Later, in the Click kernel thread -- that is, not at interrupt time --\r\na FromDevice task emits packets from that queue into the configuration.  It\r\nemits at most BURST packets per task execution; BURST is 8 by default.\r\nKeyword arguments are:\r\n\r\n\r\n PROMISC\r\n Boolean.  If true, the device is put into promiscuous mode while FromDevice is\r\nactive.  Default is false.\r\n\r\n\r\n\r\n\r\n BURST\r\n Unsigned integer.  Sets the BURST parameter.\r\n\r\n\r\n\r\n\r\n TIMESTAMP\r\n Boolean.  If true, then ensure that received packets have correctly-set\r\ntimestamp annotations.  Default is true.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then FromDevice will report a warning (rather than\r\nan error). Later, while the router is running, if a device named DEVNAME\r\nappears, FromDevice will seamlessly begin outputing its packets. Default is\r\nfalse.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n\r\n\r\n ACTIVE\r\n Boolean.  If false, then FromDevice will not accept packets from the attached\r\ndevice; instead, packets from the device are processed by Linux as usual.\r\nDefault is true.\r\n\r\n\r\n\r\n\r\n ALIGNMENT\r\n Specifies the alignment of packets emitted by this FromDevice, in the form\r\n\"ALIGN OFFSET\", such as \"4 0\".  FromDevice does not process this argument\r\nitself, but the click-align tool parses the argument and uses it in its\r\ncalculations.  The default ALIGNMENT is 4 2.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"FromDevice(DEVNAME [, keywords PROMISC, BURST, TIMESTAMP...])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/FromDevice/undefined","blockDefId":"FromDevice-1.0","ports":[{"name":"out0","portIndex":0,"role":"output","processing":"push","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":10,"cy":16,"id":"ns3_bk1_po0","multiplicity":"*","name":"out0","path":"M 8 14 L 12 14 L 12 18 L 8 18 z","portIndex":0,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":30,"cy":16,"id":"ns3_bk1_po1","multiplicity":"*","name":"vport0","path":"M 30 18 A 2 2 1 1 1 30 14 A 2 2 1 1 1 30 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk1_po0","name":"out0","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns3_bk1_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk2","name":"ToDevice","instanceName":"ToDevice0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","clickInfo":"ToDevice(vlan327)","blockDefId":"ToDevice-1.0","orientation":0,"definition":{"name":"ToDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"ToDevice(DEVNAME [, BURST, KEYWORDS])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/ToDevice/undefined","blockDefId":"ToDevice-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"pull","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk2_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"pull","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk2_po1","multiplicity":"*","name":"vport0","path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk2_po0","name":"in0","role":"input","processing":"pull","multiplicity":"*"},{"enable":true,"id":"ns3_bk2_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk3","name":"Queue","instanceName":"Queue0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","clickInfo":"Queue()","blockDefId":"Queue-1.0","orientation":0,"definition":{"name":"Queue","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","bgColor":"undefined","clickInfo":"QueueQueue(CAPACITY)","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Packet_Storage/Queue/undefined","blockDefId":"Queue-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk3_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk3_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk3_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns3_bk3_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns3_bk3_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk4","name":"Queue","instanceName":"Queue1","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","clickInfo":"Queue()","blockDefId":"Queue-1.0","orientation":0,"definition":{"name":"Queue","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","bgColor":"undefined","clickInfo":"QueueQueue(CAPACITY)","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Packet_Storage/Queue/undefined","blockDefId":"Queue-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk4_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk4_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk4_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns3_bk4_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns3_bk4_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk11","name":"EtherSwitch","instanceName":"EtherSwitch0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Ethernet","description":"Expects and produces Ethernet packets.  Each pair of corresponding ports\r\n(e.g., input 0 and output 0, and input 1 and output 1, and so forth)\r\ncorresponds to a LAN.  Acts as a learning, forwarding Ethernet switch among\r\nthose LANs.\r\nOn receiving a packet on input port I with source address A, EtherSwitch\r\nassociates A with I.  Future packets destined for A are sent to output I\r\n(unless they came from input I, in which case they are dropped).  Packets sent\r\nto an unknown destination address are forwarded to every output port, except\r\nthe one corresponding to the packet's input port.  The TIMEOUT parameter\r\naffects how long port associations last.  If it is 0, then the element does\r\nnot learn addresses, and acts like a dumb hub.\r\nKeyword arguments are:\r\n\r\n\r\n TIMEOUT\r\n The timeout for port associations, in seconds.  Any port mapping (i.e.,\r\nbinding between an address and a port number) is dropped after TIMEOUT seconds\r\nof inactivity.  If 0, the element acts like a dumb hub.  Default is 300.\r\n\r\n\r\n","clickInfo":"EtherSwitch()","blockDefId":"EtherSwitch-1.0","orientation":0,"definition":{"name":"EtherSwitch","type":"click-user","ver":"1.0","maxInstance":"*","category":"Ethernet","description":"Expects and produces Ethernet packets.  Each pair of corresponding ports\r\n(e.g., input 0 and output 0, and input 1 and output 1, and so forth)\r\ncorresponds to a LAN.  Acts as a learning, forwarding Ethernet switch among\r\nthose LANs.\r\nOn receiving a packet on input port I with source address A, EtherSwitch\r\nassociates A with I.  Future packets destined for A are sent to output I\r\n(unless they came from input I, in which case they are dropped).  Packets sent\r\nto an unknown destination address are forwarded to every output port, except\r\nthe one corresponding to the packet's input port.  The TIMEOUT parameter\r\naffects how long port associations last.  If it is 0, then the element does\r\nnot learn addresses, and acts like a dumb hub.\r\nKeyword arguments are:\r\n\r\n\r\n TIMEOUT\r\n The timeout for port associations, in seconds.  Any port mapping (i.e.,\r\nbinding between an address and a port number) is dropped after TIMEOUT seconds\r\nof inactivity.  If 0, the element acts like a dumb hub.  Default is 300.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"EtherSwitch([keywords TIMEOUT])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Ethernet/EtherSwitch/undefined","blockDefId":"EtherSwitch-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"push","val":null,"path":"M 4.666666666666667 0 L 8.666666666666668 0 L 6.666666666666667 4 z","cx":6.666666666666667,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"in1","portIndex":1,"role":"input","processing":"push","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"in2","portIndex":2,"role":"input","processing":"push","val":null,"path":"M 31.333333333333336 0 L 35.333333333333336 0 L 33.333333333333336 4 z","cx":33.333333333333336,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":3,"role":"output","processing":"push","val":null,"path":"M 4.666666666666667 14 L 8.666666666666668 14 L 8.666666666666668 18 L 4.666666666666667 18 z","cx":6.666666666666667,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":4,"role":"output","processing":"push","val":null,"path":"M 18 14 L 22 14 L 22 18 L 18 18 z","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out2","portIndex":5,"role":"output","processing":"push","val":null,"path":"M 31.333333333333336 14 L 35.333333333333336 14 L 35.333333333333336 18 L 31.333333333333336 18 z","cx":33.333333333333336,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":6.666666666666667,"cy":2,"id":"ns3_bk11_po0","multiplicity":"*","name":"in0","path":"M 4.666666666666667 0 L 8.666666666666668 0 L 6.666666666666667 4 z","portIndex":0,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk11_po1","multiplicity":"*","name":"in1","path":"M 18 0 L 22 0 L 20 4 z","portIndex":1,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":33.333333333333336,"cy":2,"id":"ns3_bk11_po2","multiplicity":"*","name":"in2","path":"M 31.333333333333336 0 L 35.333333333333336 0 L 33.333333333333336 4 z","portIndex":2,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":6.666666666666667,"cy":16,"id":"ns3_bk11_po3","multiplicity":"*","name":"out0","path":"M 4.666666666666667 14 L 8.666666666666668 14 L 8.666666666666668 18 L 4.666666666666667 18 z","portIndex":3,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk11_po4","multiplicity":"*","name":"out1","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":4,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"},{"connCount":1,"cx":33.333333333333336,"cy":16,"id":"ns3_bk11_po5","multiplicity":"*","name":"out2","path":"M 31.333333333333336 14 L 35.333333333333336 14 L 35.333333333333336 18 L 31.333333333333336 18 z","portIndex":5,"position":"bottom","processing":"push","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns0_bk12_po0","name":"in0","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po1","name":"in1","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po2","name":"in2","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po3","name":"out0","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po4","name":"out1","role":"output","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns0_bk12_po5","name":"out2","role":"output","processing":"push","multiplicity":"*"}]},{"id":"ns3_bk14","name":"KernelTap","instanceName":"KernelTap0","type":"click-user","ver":"1.0","maxInstance":"*","category":"Host_and_Socket_Communication","description":"Reads Ethernet packets from and writes Ethernet packets to a /dev/tun* or\r\n/dev/tap* device.  This allows a user-level Click to hand packets to the\r\nvirtual Ethernet device.  KernelTap will also transfer packets from the\r\nvirtual Ethernet device.\r\nKernelTap allocates a /dev/tun* or tap* device (this might fail) and runs\r\nifconfig to set the interface's local (i.e., kernel) address to ADDR and\r\nthe netmask to MASK.  If a nonzero GATEWAY IP address (which must be on the\r\nsame network as the tun) is specified, then KernelTap tries to set up a\r\ndefault route through that host.\r\nKeyword arguments are:\r\n\r\n\r\n ETHER\r\n Ethernet address. Specifies the fake device's Ethernet address. Default is\r\n00:01:02:03:04:05. On Linux, you must supply an ETHER argument, and use that\r\naddress as the destination Ethernet address for all packets sent to the tap\r\nelement; otherwise, Linux will ignore your packets. On FreeBSD, there is no\r\nway to set the Ethernet address, and any ETHER argument is silently ignored,\r\nbut it is safe to use any destination Ethernet address for packets sent to the\r\ntap.\r\n\r\n\r\n\r\n\r\n MTU\r\n Integer.  The interface's maximum transmission unit, not including the\r\nEthernet header.  Default is 1500; some operating systems do not allow it to\r\nbe set.\r\n\r\n\r\n\r\n\r\n HEADROOM\r\n Integer.  The number of bytes left empty before the packet data (to leave room\r\nfor additional encapsulation headers).  Default is 0.\r\n\r\n\r\n\r\n\r\n IGNORE_QUEUE_OVERFLOWS\r\n Boolean.  If true, don't print more than one error message when there are\r\nqueue overflow errors (ENOBUFS) when sending or receiving packets via the tun\r\ndevice.  Default is false.\r\nKernelTap accepts the same arguments as KernelTun.\r\n\r\n\r\n","clickInfo":"KernelTap(10.1.1.2/24, ETHER 02:b3:12:98:ec:70)","blockDefId":"KernelTap-1.0","orientation":0,"definition":{"name":"KernelTap","type":"click-user","ver":"1.0","maxInstance":"*","category":"Host_and_Socket_Communication","description":"Reads Ethernet packets from and writes Ethernet packets to a /dev/tun* or\r\n/dev/tap* device.  This allows a user-level Click to hand packets to the\r\nvirtual Ethernet device.  KernelTap will also transfer packets from the\r\nvirtual Ethernet device.\r\nKernelTap allocates a /dev/tun* or tap* device (this might fail) and runs\r\nifconfig to set the interface's local (i.e., kernel) address to ADDR and\r\nthe netmask to MASK.  If a nonzero GATEWAY IP address (which must be on the\r\nsame network as the tun) is specified, then KernelTap tries to set up a\r\ndefault route through that host.\r\nKeyword arguments are:\r\n\r\n\r\n ETHER\r\n Ethernet address. Specifies the fake device's Ethernet address. Default is\r\n00:01:02:03:04:05. On Linux, you must supply an ETHER argument, and use that\r\naddress as the destination Ethernet address for all packets sent to the tap\r\nelement; otherwise, Linux will ignore your packets. On FreeBSD, there is no\r\nway to set the Ethernet address, and any ETHER argument is silently ignored,\r\nbut it is safe to use any destination Ethernet address for packets sent to the\r\ntap.\r\n\r\n\r\n\r\n\r\n MTU\r\n Integer.  The interface's maximum transmission unit, not including the\r\nEthernet header.  Default is 1500; some operating systems do not allow it to\r\nbe set.\r\n\r\n\r\n\r\n\r\n HEADROOM\r\n Integer.  The number of bytes left empty before the packet data (to leave room\r\nfor additional encapsulation headers).  Default is 0.\r\n\r\n\r\n\r\n\r\n IGNORE_QUEUE_OVERFLOWS\r\n Boolean.  If true, don't print more than one error message when there are\r\nqueue overflow errors (ENOBUFS) when sending or receiving packets via the tun\r\ndevice.  Default is false.\r\nKernelTap accepts the same arguments as KernelTun.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"KernelTap(ADDR/MASK [, GATEWAY, keywords ETHER, MTU, HEADROOM, IGNORE_QUEUE_OVERFLOWS])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Host_and_Socket_Communication/KernelTap/undefined","blockDefId":"KernelTap-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk14_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk14_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk14_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns3_bk14_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns3_bk14_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk18","name":"Queue","instanceName":"Queue2","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","clickInfo":"Queue()","blockDefId":"Queue-1.0","orientation":0,"definition":{"name":"Queue","type":"click-user","ver":"1.0","maxInstance":"*","category":"Packet_Storage","description":"Stores incoming packets in a first-in-first-out queue.\r\nDrops incoming packets if the queue already holds CAPACITY packets.\r\nThe default for CAPACITY is 1000.\r\nQueue notifies interested parties when it becomes empty and when a\r\nformerly-empty queue receives a packet.  The empty notification takes place\r\nsome time after the queue goes empty, to prevent thrashing for queues that\r\nhover around 1 or 2 packets long.  This behavior is the same as that of\r\nNotifierQueue.  (See QuickNoteQueue for an alternative.)  Queue additionally\r\nnotifies interested parties that it is non-full, and when a formerly-full\r\nqueue gains some free space.  In all respects but notification, Queue behaves\r\nexactly like SimpleQueue.\r\nYou may also use the old element name \"FullNoteQueue\".\r\nMultithreaded Click note: Queue is designed to be used in an environment\r\nwith at most one concurrent pusher and at most one concurrent puller.  Thus,\r\nat most one thread pushes to the Queue at a time and at most one thread pulls\r\nfrom the Queue at a time.  Different threads can push to and pull from the\r\nQueue concurrently, however.  See ThreadSafeQueue for a queue that can support\r\nmultiple concurrent pushers and pullers.\r\n","bgColor":"undefined","clickInfo":"QueueQueue(CAPACITY)","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Packet_Storage/Queue/undefined","blockDefId":"Queue-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"*","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 8 14 L 12 14 L 12 18 L 8 18 z","cx":10,"cy":16,"multiplicity":"*","schemeName":"Click"},{"name":"out1","portIndex":2,"role":"output","processing":"*","val":null,"path":"M 28 14 L 32 14 L 32 18 L 28 18 z","cx":30,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk18_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"*","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk18_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk18_po0","name":"in0","role":"input","processing":"*","multiplicity":"*"},{"enable":true,"id":"ns3_bk18_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"},{"enable":false,"id":"ns3_bk18_po2","name":"out1","role":"output","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk21","name":"ToDevice","instanceName":"ToDevice1","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","clickInfo":"ToDevice(vlan309)","blockDefId":"ToDevice-1.0","orientation":0,"definition":{"name":"ToDevice","type":"click-user","ver":"1.0","maxInstance":"*","category":"Network_Devices","description":"This manual page describes the Linux kernel module version of the ToDevice\r\nelement. For the user-level element, read the ToDevice.u manual page.\r\nPulls packets from its single input and sends them out the Linux network\r\ninterface named DEVNAME. DEVNAME may also be an Ethernet address, in which\r\ncase ToDevice searches for a device with that address.\r\nSends up to BURST packets each time it is scheduled. By default, BURST is 16.\r\nFor good performance, you should set BURST to be 8 times the number of\r\nelements that could generate packets for this device.\r\nPackets must have a link header. For Ethernet, ToDevice makes sure every\r\npacket is at least 60 bytes long (but see NO_PAD).\r\nKeyword arguments are:\r\n\r\n\r\n BURST\r\n Unsigned integer. Same as the BURST argument.\r\n\r\n\r\n\r\n\r\n QUIET\r\n Boolean.  If true, then suppress device up/down messages.  Default is false.\r\n\r\n\r\n\r\n\r\n QUEUE\r\n Integer.  The transmit queue to send to.  Default is 0.\r\n\r\n\r\n\r\n\r\n ALLOW_NONEXISTENT\r\n Allow nonexistent devices. If true, and no device named DEVNAME exists when\r\nthe router is initialized, then ToDevice will report a warning (rather than an\r\nerror). Later, while the router is running, if a device named DEVNAME appears,\r\nToDevice will seamlessly begin sending packets to it. Default is false.\r\n\r\n\r\n\r\n\r\n NO_PAD\r\n Boolean. If true, don't force packets to be at least 60 bytes (the\r\nminimum Ethernet packet size).  This is useful because some 802.11\r\ncards can send shorter Ethernet format packets.  Defaults false.\r\n\r\n\r\n\r\n\r\n UP_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ncomes up.\r\n\r\n\r\n\r\n\r\n DOWN_CALL\r\n Write handler.  If supplied, this handler is called when the device or link\r\ngoes down.\r\n\r\n\r\n","bgColor":"undefined","clickInfo":"ToDevice(DEVNAME [, BURST, KEYWORDS])","elementclassText":"","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/Network_Devices/ToDevice/undefined","blockDefId":"ToDevice-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"pull","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"vport0","portIndex":0,"role":"vport","processing":"*","val":null,"path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk21_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"pull","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk21_po1","multiplicity":"*","name":"vport0","path":"M 20 18 A 2 2 1 1 1 20 14 A 2 2 1 1 1 20 18","portIndex":0,"position":"bottom","processing":"*","role":"vport","val":null,"schemeName":"Click"}],"elementclassText":"","portsTemplate":[{"enable":true,"id":"ns3_bk21_po0","name":"in0","role":"input","processing":"pull","multiplicity":"*"},{"enable":true,"id":"ns3_bk21_po1","name":"vport0","role":"vport","processing":"*","multiplicity":"*"}]},{"id":"ns3_bk27","name":"NetCacheEgress","instanceName":"NetCacheEgress0","type":"click-user","ver":"1.0","maxInstance":"*","category":"COMPOUND_ELEMENTS","description":"","clickInfo":"NetCacheEgress_1_0(10.1.1.1, 50000, 50001)","blockDefId":"NetCacheEgress-1.0","orientation":0,"definition":{"name":"NetCacheEgress","type":"click-user","ver":"1.0","maxInstance":"*","category":"COMPOUND_ELEMENTS","description":"","bgColor":"rgb(255, 255, 255)","clickInfo":"NetCacheEgress_1_0($INGRESS_IP, $PORT1, $PORT2)","isCompound":true,"elementclassText":"elementclass NetCacheEgress_1_0 {\r\n    $INGRESS_IP, $PORT1, $PORT2 |\r\n    Classifier0 :: Classifier(12/0800, -);\r\n    Align0 :: Align(4, 0);\r\n    Strip0 :: Strip(14);\r\n    CheckIPHeader0 :: CheckIPHeader();\r\n    IPClassifier0 :: IPClassifier(tcp, -);\r\n    NetCacheElement0 :: NetCacheElement(EGRESS);\r\n    Queue0 :: Queue();\r\n    Queue1 :: Queue();\r\n    Socket0 :: Socket(Udp, $INGRESS_IP, $PORT1);\r\n    Socket1 :: Socket(Udp, $INGRESS_IP, $PORT2);\r\n    Unstrip0 :: Unstrip(14);\r\n    Unstrip1 :: Unstrip(14);\r\n    SetIPChecksum0 :: SetIPChecksum();\r\n    Null0 :: Null;\r\n\r\n    input -> Classifier0;\r\n    Classifier0 -> Strip0;\r\n    Classifier0[1] -> Null0;\r\n    Strip0 -> Align0;\r\n    Align0 -> CheckIPHeader0;\r\n    CheckIPHeader0 -> IPClassifier0;\r\n    IPClassifier0[1] -> Unstrip0;\r\n    Unstrip0 -> Null0;\r\n    IPClassifier0 -> NetCacheElement0;\r\n    NetCacheElement0 -> SetIPChecksum0;\r\n    SetIPChecksum0 -> Unstrip1;\r\n    Unstrip1 -> Null0;\r\n    NetCacheElement0[1] -> Queue0;\r\n    NetCacheElement0[2] -> Queue1;\r\n    Queue0 -> Socket0;\r\n    Queue1 -> Socket1;\r\n    Null0 -> output;\r\n } ","width":40,"height":18,"rx":2,"ry":2,"id":null,"x":null,"y":null,"imgSrc":"api/GetBlockImgSrcSvg/COMPOUND_ELEMENTS/NetCacheEgress/undefined","blockDefId":"NetCacheEgress-1.0","ports":[{"name":"in0","portIndex":0,"role":"input","processing":"push","val":null,"path":"M 18 0 L 22 0 L 20 4 z","cx":20,"cy":2,"multiplicity":"*","schemeName":"Click"},{"name":"out0","portIndex":1,"role":"output","processing":"*","val":null,"path":"M 18 14 L 22 14 L 22 18 L 18 18 z","cx":20,"cy":16,"multiplicity":"*","schemeName":"Click"}]},"ports":[{"connCount":1,"cx":20,"cy":2,"id":"ns3_bk27_po0","multiplicity":"*","name":"in0","path":"M 18 0 L 22 0 L 20 4 z","portIndex":0,"position":"top","processing":"push","role":"input","val":null,"schemeName":"Click"},{"connCount":1,"cx":20,"cy":16,"id":"ns3_bk27_po1","multiplicity":"*","name":"out0","path":"M 18 14 L 22 14 L 22 18 L 18 18 z","portIndex":1,"position":"bottom","processing":"*","role":"output","val":null,"schemeName":"Click"}],"isCompound":true,"elementclassText":"elementclass NetCacheEgress_1_0 {\r\n    $INGRESS_IP, $PORT1, $PORT2 |\r\n    Classifier0 :: Classifier(12/0800, -);\r\n    Align0 :: Align(4, 0);\r\n    Strip0 :: Strip(14);\r\n    CheckIPHeader0 :: CheckIPHeader();\r\n    IPClassifier0 :: IPClassifier(tcp, -);\r\n    NetCacheElement0 :: NetCacheElement(EGRESS);\r\n    Queue0 :: Queue();\r\n    Queue1 :: Queue();\r\n    Socket0 :: Socket(Udp, $INGRESS_IP, $PORT1);\r\n    Socket1 :: Socket(Udp, $INGRESS_IP, $PORT2);\r\n    Unstrip0 :: Unstrip(14);\r\n    Unstrip1 :: Unstrip(14);\r\n    SetIPChecksum0 :: SetIPChecksum();\r\n    Null0 :: Null;\r\n\r\n    input -> Classifier0;\r\n    Classifier0 -> Strip0;\r\n    Classifier0[1] -> Null0;\r\n    Strip0 -> Align0;\r\n    Align0 -> CheckIPHeader0;\r\n    CheckIPHeader0 -> IPClassifier0;\r\n    IPClassifier0[1] -> Unstrip0;\r\n    Unstrip0 -> Null0;\r\n    IPClassifier0 -> NetCacheElement0;\r\n    NetCacheElement0 -> SetIPChecksum0;\r\n    SetIPChecksum0 -> Unstrip1;\r\n    Unstrip1 -> Null0;\r\n    NetCacheElement0[1] -> Queue0;\r\n    NetCacheElement0[2] -> Queue1;\r\n    Queue0 -> Socket0;\r\n    Queue1 -> Socket1;\r\n    Null0 -> output;\r\n } ","portsTemplate":[{"enable":true,"id":"ns3_bk27_po0","name":"in0","role":"input","processing":"push","multiplicity":"*"},{"enable":true,"id":"ns3_bk27_po1","name":"out0","role":"output","processing":"*","multiplicity":"*"}]}],"blkTotalCnt":28,"vpoList":[{"id":"ns3_vp0","name":"vlan327","ports":[{"connCount":2,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"right","role":"nsvport"}],"mac":"02:ed:d2:1f:08:98"},{"id":"ns3_vp1","name":"vlan309","ports":[{"connCount":2,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"left","role":"nsvport"}],"mac":"02:8d:4d:ae:b0:9b"},{"id":"ns3_vp2","name":"vlan332","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"left","role":"nsvport"}],"mac":"02:91:0a:f9:79:d0"}],"vpoTotalCnt":3,"lnkList":[{"id":"ns3_link11","sourceId":"ns3_bk1","targetId":"ns3_bk11","left":false,"right":true,"srcPortIdx":0,"dstPortIdx":1,"className":"link bblink"},{"id":"ns3_link15","sourceId":"ns3_bk14","targetId":"ns3_bk11","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":2,"className":"link bblink"},{"id":"ns3_link16","sourceId":"ns3_bk11","targetId":"ns3_bk3","left":false,"right":true,"srcPortIdx":3,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link17","sourceId":"ns3_bk3","targetId":"ns3_bk2","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link18","sourceId":"ns3_bk11","targetId":"ns3_bk4","left":false,"right":true,"srcPortIdx":4,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link19","sourceId":"ns3_bk11","targetId":"ns3_bk18","left":false,"right":true,"srcPortIdx":5,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link20","sourceId":"ns3_bk18","targetId":"ns3_bk14","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link23","sourceId":"ns3_bk4","targetId":"ns3_bk21","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link42","sourceId":"ns3_bk0","targetId":"ns3_vp0","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns3_link44","sourceId":"ns3_bk1","targetId":"ns3_vp1","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns3_link45","sourceId":"ns3_bk2","targetId":"ns3_vp0","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns3_link46","sourceId":"ns3_bk21","targetId":"ns3_vp1","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bvlink"},{"id":"ns3_link47","sourceId":"ns3_bk0","targetId":"ns3_bk27","left":false,"right":true,"srcPortIdx":0,"dstPortIdx":0,"className":"link bblink"},{"id":"ns3_link48","sourceId":"ns3_bk27","targetId":"ns3_bk11","left":false,"right":true,"srcPortIdx":1,"dstPortIdx":0,"className":"link bblink"}],"lnkTotalCnt":49,"sliceName":"","hostname":""},{"id":"ns4","name":"PG:NS:PN2","blkList":[],"blkTotalCnt":0,"vpoList":[{"id":"ns4_vp0","name":"vlan309","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"right","role":"nsvport"}],"mac":"02:52:76:52:a6:c1"},{"id":"ns4_vp1","name":"vlan308","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"top","role":"nsvport"}],"mac":"02:91:2b:30:01:d7"}],"vpoTotalCnt":2,"lnkList":[],"lnkTotalCnt":0,"sliceName":"","hostname":""},{"id":"ns5","name":"PG:NS:PN3","blkList":[],"blkTotalCnt":22,"vpoList":[{"id":"ns5_vp0","name":"vlan308","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"bottom","role":"nsvport"}],"mac":"02:c2:37:a8:43:cc"},{"id":"ns5_vp1","name":"vlan332","ports":[{"connCount":0,"cx":0,"cy":0,"path":"M 4 0 L 8 0 L 6 4 z","position":"right","role":"nsvport"}],"mac":"02:b2:09:b5:25:63"}],"vpoTotalCnt":2,"lnkList":[],"lnkTotalCnt":24,"sliceName":"","hostname":""}],"vvList":[{"id":"vvlink0","sourceId":"ns0","targetId":"ns3","left":false,"right":true,"srcVportId":"ns0_vp0","tgtVportId":"ns3_vp0","className":"link vvlink"},{"id":"vvlink1","sourceId":"ns0","targetId":"ns1","left":false,"right":true,"srcVportId":"ns0_vp1","tgtVportId":"ns1_vp0","className":"link vvlink"},{"id":"vvlink2","sourceId":"ns2","targetId":"ns1","left":false,"right":true,"srcVportId":"ns2_vp0","tgtVportId":"ns1_vp1","className":"link vvlink"},{"id":"vvlink3","sourceId":"ns0","targetId":"ns2","left":false,"right":true,"srcVportId":"ns0_vp2","tgtVportId":"ns2_vp1","className":"link vvlink"},{"id":"vvlink4","sourceId":"ns5","targetId":"ns3","left":false,"right":true,"srcVportId":"ns5_vp1","tgtVportId":"ns3_vp2","className":"link vvlink"},{"id":"vvlink5","sourceId":"ns3","targetId":"ns4","left":false,"right":true,"srcVportId":"ns3_vp1","tgtVportId":"ns4_vp0","className":"link vvlink"},{"id":"vvlink6","sourceId":"ns4","targetId":"ns5","left":false,"right":true,"srcVportId":"ns4_vp1","tgtVportId":"ns5_vp0","className":"link vvlink"}]}